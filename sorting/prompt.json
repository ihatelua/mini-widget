{
  "new_chat_prompt": {
    "language": "ko",
    "title": "정렬 시각화 프로젝트 이어서 진행",
    "instructions": [
      "아래 project_state(요구사항/구조/소스코드)를 기준으로 정렬 시각화 웹페이지를 계속 개선한다.",
      "기능(JS 로직)은 유지하면서 UI/UX, 알고리즘 추가, 애니메이션/제어(PAUSE/RESUME/STOP) 개선을 진행한다.",
      "모든 정렬은 막대(bar) + 숫자 라벨이 있고, swap 기반은 FLIP 애니메이션으로 실제로 이동하며, write 기반은 값 덮어쓰기(writeMark)로 변경 흐름을 보여준다.",
      "정렬 방향(오름/내림) 토글이 있고, 랜덤 생성/막대 개수 슬라이더/속도 슬라이더가 있다.",
      "상단에는 선택된 알고리즘 한글 설명 카드가 있고, 정렬 중/일시정지/완료/중지 상태가 표시된다."
    ]
  },
  "project_state": {
    "project_name": "sorting-visualizer",
    "goals": [
      "막대(bar)로 정렬 알고리즘을 시각화",
      "swap 기반 정렬은 스왑 시 막대가 실제로 좌/우 이동(FLIP)하며 애니메이션",
      "write 기반 정렬은 값 재배치(덮어쓰기) 중심 애니메이션",
      "정렬 방향(오름/내림) 토글, 랜덤 생성, 막대 개수/속도 조절",
      "일시정지(PAUSE) / 재개(RESUME) / 중지(STOP) 지원",
      "상단 알고리즘 설명 카드(한글)"
    ],
    "features": {
      "ui_controls": [
        "알고리즘 선택(select)",
        "RANDOM 버튼",
        "COUNT 슬라이더(막대 개수)",
        "SPEED 슬라이더(애니메이션 속도)",
        "DESC 토글(내림차순)",
        "GO 버튼",
        "PAUSE / RESUME / STOP 버튼"
      ],
      "visuals": [
        "막대 아래 숫자 라벨 표시",
        "compare 상태: 노랑",
        "write 상태: 연노랑",
        "sorted 상태: 초록"
      ],
      "algorithms_swap_based": [
        "Bubble",
        "Selection",
        "Insertion",
        "Quick",
        "Shell",
        "Cocktail Shaker",
        "Comb",
        "Gnome",
        "Heap"
      ],
      "algorithms_write_based": [
        "Merge",
        "Counting",
        "Radix (LSD)",
        "Bucket"
      ],
      "algorithms_advanced": [
        "IntroSort (Quick + Heap + Insertion 하이브리드)",
        "TimSort (교육용 단순화: run 탐지/확장 + merge)"
      ]
    },
    "prompt_history_summary": [
      {
        "step": 1,
        "user_request": "버블정렬부터 막대 애니메이션 정렬 시각화(HTML/CSS/JS 분리)",
        "assistant_result": "막대 생성, 비교(노랑), swap 구현"
      },
      {
        "step": 2,
        "user_request": "스왑이 '그냥 값이 바뀌는' 게 아니라 막대가 실제로 좌우 이동하는 애니메이션",
        "assistant_result": "FLIP 기반 DOM swap 애니메이션(비인접 swap 안전 처리)"
      },
      {
        "step": 3,
        "user_request": "내림차순 토글, 막대 크기, 추가 정렬(Merge/Heap), 랜덤 버튼/슬라이더",
        "assistant_result": "알고리즘 확장 및 UI 추가"
      },
      {
        "step": 4,
        "user_request": "파일이 많아져서 정리 필요",
        "assistant_result": "core/algorithms로 구조 정리 + registry 도입"
      },
      {
        "step": 5,
        "user_request": "IntroSort/TimSort 추가",
        "assistant_result": "advanced.js로 추가"
      },
      {
        "step": 6,
        "user_request": "2025 스타일 깔끔한 디자인 + 막대 기본색 인디고로 변경",
        "assistant_result": "미니멀 카드 UI + CSS 변수로 색상 제어(--bar=#6366f1)"
      },
      {
        "step": 7,
        "user_request": "상단 알고리즘 설명 카드(한글) + PAUSE/RESUME/STOP",
        "assistant_result": "설명 카드 + SortController + sleep() 제어로 전 알고리즘에 일괄 적용"
      }
    ],
    "how_to_run": {
      "requirements": [
        "브라우저(Chrome/Edge 등)",
        "정적 파일 제공(예: VSCode Live Server 권장)"
      ],
      "steps": [
        "아래 file_tree 구조대로 파일을 생성/교체",
        "index.html을 Live Server로 열거나 브라우저에서 직접 열기",
        "RANDOM으로 데이터 생성 후 GO로 실행",
        "PAUSE/RESUME/STOP으로 제어",
        "DESC 토글로 내림차순 정렬"
      ]
    }
  },
  "file_tree": [
    "index.html",
    "css/main.css",
    "css/controls.css",
    "js/app.js",
    "js/core/registry.js",
    "js/core/animation.js",
    "js/core/bars.js",
    "js/algorithms/swap.js",
    "js/algorithms/heap.js",
    "js/algorithms/write.js",
    "js/algorithms/advanced.js"
  ],
  "files": [
    {
      "path": "index.html",
      "type": "html",
      "content": [
        "<!doctype html>",
        "<html lang='ko'>",
        "<head>",
        "  <meta charset='utf-8' />",
        "  <meta name='viewport' content='width=device-width, initial-scale=1' />",
        "  <title>Sorting Visualizer</title>",
        "  <link rel='stylesheet' href='css/main.css' />",
        "  <link rel='stylesheet' href='css/controls.css' />",
        "</head>",
        "<body>",
        "",
        "<header class='topbar'>Sorting Visualizer</header>",
        "",
        "<section class='algo-card' id='algoCard'>",
        "  <div class='algo-card__head'>",
        "    <div>",
        "      <div class='algo-card__title' id='algoTitle'>알고리즘</div>",
        "      <div class='algo-card__status' id='algoStatus'>대기 중</div>",
        "    </div>",
        "    <div class='algo-card__meta' id='algoMeta'>복잡도: - / 안정성: -</div>",
        "  </div>",
        "  <div class='algo-card__desc' id='algoDesc'>",
        "    알고리즘을 선택하면 여기 설명이 표시됩니다.",
        "  </div>",
        "</section>",
        "",
        "<section class='controls'>",
        "  <select id='algo'></select>",
        "  <button id='random'>RANDOM</button>",
        "  <label>",
        "    COUNT",
        "    <input id='count' type='range' min='5' max='40' value='20' />",
        "  </label>",
        "  <label>",
        "    SPEED",
        "    <input id='speed' type='range' min='1' max='5' value='3' />",
        "  </label>",
        "  <label class='toggle'>",
        "    DESC",
        "    <input id='direction' type='checkbox' />",
        "  </label>",
        "  <button id='go'>GO</button>",
        "  <button id='pause'>PAUSE</button>",
        "  <button id='resume'>RESUME</button>",
        "  <button id='stop'>STOP</button>",
        "</section>",
        "",
        "<div class='stage'>",
        "  <div id='bars' class='bars'></div>",
        "</div>",
        "",
        "<script src='js/core/registry.js'></script>",
        "<script src='js/core/animation.js'></script>",
        "<script src='js/core/bars.js'></script>",
        "",
        "<script src='js/algorithms/swap.js'></script>",
        "<script src='js/algorithms/heap.js'></script>",
        "<script src='js/algorithms/write.js'></script>",
        "<script src='js/algorithms/advanced.js'></script>",
        "",
        "<script src='js/app.js'></script>",
        "",
        "</body>",
        "</html>"
      ]
    },
    {
      "path": "css/main.css",
      "type": "css",
      "content": [
        ":root{",
        "  --bar-width: 26px;",
        "  --bar-gap: 10px;",
        "",
        "  --bg-0: #f7f8fb;",
        "  --bg-1: #eef2f7;",
        "",
        "  --surface: #ffffff;",
        "  --surface-2: #f8fafc;",
        "",
        "  --text: #0f172a;",
        "  --muted: #64748b;",
        "  --border: #e2e8f0;",
        "",
        "  /* 막대 기본색(사용자가 인디고로 변경) */",
        "  --bar: #6366f1;",
        "  --compare: #f5b301;",
        "  --write: #ffcf5a;",
        "  --sorted: #22c55e;",
        "",
        "  --shadow: 0 10px 30px rgba(15, 23, 42, 0.08);",
        "  --shadow-soft: 0 6px 16px rgba(15, 23, 42, 0.06);",
        "",
        "  --r-xl: 20px;",
        "  --r-lg: 16px;",
        "  --r-md: 12px;",
        "  --r-sm: 10px;",
        "",
        "  --ease: cubic-bezier(0.16, 1, 0.3, 1);",
        "}",
        "",
        "*{ box-sizing: border-box; }",
        "html, body{ height: 100%; }",
        "",
        "body{",
        "  margin:0;",
        "  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Arial, sans-serif;",
        "  color: var(--text);",
        "  background:",
        "    radial-gradient(1200px 700px at 15% 10%, #ffffff, transparent 55%),",
        "    radial-gradient(900px 500px at 85% 25%, #eef6ff, transparent 60%),",
        "    linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 100%);",
        "}",
        "",
        ".topbar{",
        "  position: sticky;",
        "  top: 0;",
        "  z-index: 10;",
        "  height: 64px;",
        "  display:flex;",
        "  align-items:center;",
        "  padding: 0 18px;",
        "  font-size: 20px;",
        "  font-weight: 800;",
        "  letter-spacing: -0.2px;",
        "  background: rgba(255,255,255,0.9);",
        "  border-bottom: 1px solid var(--border);",
        "  backdrop-filter: saturate(120%);",
        "}",
        "",
        ".stage{",
        "  height: min(520px, calc(100vh - 180px));",
        "  display:flex;",
        "  justify-content:center;",
        "  align-items:flex-end;",
        "  padding: 22px 16px 28px;",
        "}",
        "",
        ".bars{",
        "  display:flex;",
        "  gap: var(--bar-gap);",
        "  align-items:flex-end;",
        "  padding: 18px 18px 14px;",
        "  border-radius: var(--r-xl);",
        "  background: var(--surface);",
        "  border: 1px solid var(--border);",
        "  box-shadow: var(--shadow);",
        "}",
        "",
        ".item{",
        "  display:flex;",
        "  flex-direction:column;",
        "  align-items:center;",
        "  transition: transform 400ms var(--ease);",
        "  will-change: transform;",
        "}",
        "",
        ".bar{",
        "  width: var(--bar-width);",
        "  border-radius: 10px;",
        "  background: var(--bar);",
        "  box-shadow: var(--shadow-soft);",
        "  transition: height 300ms var(--ease), background 200ms var(--ease), filter 200ms var(--ease);",
        "}",
        "",
        ".label{",
        "  margin-top: 10px;",
        "  font-size: 12px;",
        "  font-weight: 800;",
        "  color: var(--muted);",
        "  line-height: 1;",
        "  padding: 4px 8px;",
        "  border-radius: 999px;",
        "  background: var(--surface-2);",
        "  border: 1px solid var(--border);",
        "}",
        "",
        ".item.compare .bar{",
        "  background: var(--compare);",
        "  filter: brightness(1.02);",
        "}",
        "",
        ".item.write .bar{",
        "  background: var(--write);",
        "}",
        "",
        ".item.sorted .bar{",
        "  background: var(--sorted);",
        "}",
        "",
        ":focus-visible{",
        "  outline: 3px solid rgba(59, 130, 246, 0.45);",
        "  outline-offset: 3px;",
        "  border-radius: 12px;",
        "}",
        "",
        "/* ===== Algorithm Card ===== */",
        ".algo-card{",
        "  margin: 16px auto 0;",
        "  width: min(980px, calc(100% - 24px));",
        "  background: var(--surface);",
        "  border: 1px solid var(--border);",
        "  border-radius: var(--r-xl);",
        "  box-shadow: var(--shadow);",
        "  padding: 14px 16px;",
        "}",
        "",
        ".algo-card__head{",
        "  display:flex;",
        "  align-items:flex-start;",
        "  justify-content: space-between;",
        "  gap: 12px;",
        "}",
        "",
        ".algo-card__title{",
        "  font-size: 15px;",
        "  font-weight: 900;",
        "  letter-spacing: -0.2px;",
        "}",
        "",
        ".algo-card__status{",
        "  margin-top: 4px;",
        "  font-size: 12px;",
        "  font-weight: 800;",
        "  color: var(--muted);",
        "}",
        "",
        ".algo-card__meta{",
        "  font-size: 12px;",
        "  font-weight: 800;",
        "  color: var(--muted);",
        "  white-space: nowrap;",
        "}",
        "",
        ".algo-card__desc{",
        "  margin-top: 10px;",
        "  font-size: 13px;",
        "  line-height: 1.55;",
        "  color: rgba(15, 23, 42, 0.88);",
        "}",
        "",
        ".algo-card[data-state='running'] .algo-card__status{ color: #2563eb; }",
        ".algo-card[data-state='paused'] .algo-card__status{ color: #f59e0b; }",
        ".algo-card[data-state='done'] .algo-card__status{ color: #16a34a; }",
        ".algo-card[data-state='stopped'] .algo-card__status{ color: #ef4444; }"
      ]
    },
    {
      "path": "css/controls.css",
      "type": "css",
      "content": [
        ".controls{",
        "  margin: 16px auto 0;",
        "  width: min(980px, calc(100% - 24px));",
        "  display:flex;",
        "  align-items:center;",
        "  gap: 12px;",
        "  flex-wrap: wrap;",
        "  padding: 14px 14px;",
        "  border-radius: 18px;",
        "  background: #ffffff;",
        "  border: 1px solid #e2e8f0;",
        "  box-shadow: 0 10px 25px rgba(15, 23, 42, 0.06);",
        "}",
        "",
        ".controls select{",
        "  height: 44px;",
        "  padding: 0 12px;",
        "  border-radius: 12px;",
        "  background: #ffffff;",
        "  border: 1px solid #e2e8f0;",
        "  font-weight: 800;",
        "  color: #0f172a;",
        "}",
        "",
        ".controls label{",
        "  display:flex;",
        "  align-items:center;",
        "  gap: 10px;",
        "  padding: 8px 10px;",
        "  border-radius: 12px;",
        "  background: #f8fafc;",
        "  border: 1px solid #e2e8f0;",
        "  font-size: 12px;",
        "  font-weight: 900;",
        "  letter-spacing: 0.3px;",
        "  color: #334155;",
        "}",
        "",
        ".controls input[type='range']{",
        "  width: 160px;",
        "}",
        "",
        ".controls .toggle input{",
        "  width: 18px;",
        "  height: 18px;",
        "}",
        "",
        ".controls button{",
        "  height: 44px;",
        "  padding: 0 14px;",
        "  border-radius: 12px;",
        "  font-weight: 900;",
        "  letter-spacing: 0.2px;",
        "  cursor: pointer;",
        "  transition: transform 120ms cubic-bezier(0.16, 1, 0.3, 1), box-shadow 120ms, background 120ms, border-color 120ms;",
        "}",
        "",
        "/* RANDOM: outline */",
        ".controls #random{",
        "  background: #ffffff;",
        "  border: 1px solid #cbd5e1;",
        "  color: #0f172a;",
        "}",
        ".controls #random:hover{",
        "  background: #f8fafc;",
        "  transform: translateY(-1px);",
        "}",
        "",
        "/* GO: primary */",
        ".controls #go{",
        "  background: #2563eb;",
        "  border: 1px solid #2563eb;",
        "  color: #ffffff;",
        "  box-shadow: 0 12px 20px rgba(37, 99, 235, 0.18);",
        "}",
        ".controls #go:hover{",
        "  background: #1d4ed8;",
        "  border-color: #1d4ed8;",
        "  transform: translateY(-1px);",
        "}",
        "",
        "/* PAUSE / RESUME / STOP: secondary outline */",
        ".controls #pause,",
        ".controls #resume{",
        "  background: #ffffff;",
        "  border: 1px solid #cbd5e1;",
        "  color: #0f172a;",
        "}",
        ".controls #pause:hover,",
        ".controls #resume:hover{",
        "  background: #f8fafc;",
        "  transform: translateY(-1px);",
        "}",
        "",
        ".controls #stop{",
        "  background: #ffffff;",
        "  border: 1px solid rgba(239, 68, 68, 0.55);",
        "  color: #ef4444;",
        "}",
        ".controls #stop:hover{",
        "  background: rgba(239, 68, 68, 0.06);",
        "  transform: translateY(-1px);",
        "}",
        "",
        ".controls button:disabled{",
        "  opacity: 0.55;",
        "  cursor: not-allowed;",
        "  transform: none;",
        "  box-shadow: none;",
        "}"
      ]
    },
    {
      "path": "js/core/registry.js",
      "type": "js",
      "content": [
        "// 전역 레지스트리: 알고리즘 등록/조회",
        "window.SortRegistry = (() => {",
        "  const map = new Map(); // id -> { id, name, type, run }",
        "",
        "  function register(def){",
        "    map.set(def.id, def);",
        "  }",
        "",
        "  function get(id){",
        "    return map.get(id);",
        "  }",
        "",
        "  function list(){",
        "    return [...map.values()];",
        "  }",
        "",
        "  return { register, get, list };",
        "})();"
      ]
    },
    {
      "path": "js/core/animation.js",
      "type": "js",
      "content": [
        "// 실행 제어기(PAUSE/RESUME/STOP)",
        "window.SortController = (() => {",
        "  let paused = false;",
        "  let stopped = false;",
        "",
        "  function pause(){ paused = true; }",
        "  function resume(){ paused = false; }",
        "  function stop(){ stopped = true; paused = false; }",
        "  function reset(){ stopped = false; paused = false; }",
        "",
        "  function isPaused(){ return paused; }",
        "  function isStopped(){ return stopped; }",
        "",
        "  return { pause, resume, stop, reset, isPaused, isStopped };",
        "})();",
        "",
        "function getDelay(){",
        "  const v = Number(document.getElementById('speed').value);",
        "  return {1:800,2:600,3:400,4:250,5:150}[v] ?? 400;",
        "}",
        "",
        "// Pause/Stop을 존중하는 sleep",
        "async function sleep(ms){",
        "  const tick = 25;",
        "  let left = ms;",
        "",
        "  while (left > 0) {",
        "    if (SortController.isStopped()) {",
        "      throw new Error('SORT_STOPPED');",
        "    }",
        "",
        "    while (SortController.isPaused()) {",
        "      if (SortController.isStopped()) {",
        "        throw new Error('SORT_STOPPED');",
        "      }",
        "      await new Promise(r => setTimeout(r, tick));",
        "    }",
        "",
        "    const step = Math.min(tick, left);",
        "    await new Promise(r => setTimeout(r, step));",
        "    left -= step;",
        "  }",
        "}",
        "",
        "// FLIP 스왑(인접/비인접 모두 안전)",
        "function flipSwap(container, i, j){",
        "  if (i === j) return;",
        "",
        "  const items = [...container.children];",
        "  const a = items[i];",
        "  const b = items[j];",
        "",
        "  const before = new Map();",
        "  items.forEach(el => before.set(el, el.getBoundingClientRect()));",
        "",
        "  const placeholder = document.createElement('div');",
        "  placeholder.style.display = 'none';",
        "",
        "  container.insertBefore(placeholder, a);",
        "  container.replaceChild(a, b);",
        "  container.replaceChild(b, placeholder);",
        "",
        "  [...container.children].forEach(el => {",
        "    const bRect = before.get(el);",
        "    const aRect = el.getBoundingClientRect();",
        "    const dx = bRect.left - aRect.left;",
        "    const dy = bRect.top - aRect.top;",
        "",
        "    el.style.transition = 'none';",
        "    el.style.transform = `translate(${dx}px, ${dy}px)`;",
        "  });",
        "",
        "  container.getBoundingClientRect();",
        "",
        "  requestAnimationFrame(() => {",
        "    [...container.children].forEach(el => {",
        "      el.style.transition = 'transform 400ms ease';",
        "      el.style.transform = '';",
        "    });",
        "  });",
        "}"
      ]
    },
    {
      "path": "js/core/bars.js",
      "type": "js",
      "content": [
        "function itemAt(c, i){",
        "  return c.children[i];",
        "}",
        "",
        "function valueAt(c, i){",
        "  return Number(itemAt(c, i).dataset.value);",
        "}",
        "",
        "function setValueAt(c, i, v){",
        "  const it = itemAt(c, i);",
        "  it.dataset.value = String(v);",
        "  it.querySelector('.bar').style.height = `${v * 3}px`;",
        "  it.querySelector('.label').textContent = String(v);",
        "}",
        "",
        "function clearMarks(c){",
        "  [...c.children].forEach(el => el.classList.remove('compare','sorted','write'));",
        "}",
        "",
        "function markCompare(c, i, j){",
        "  itemAt(c, i).classList.add('compare');",
        "  itemAt(c, j).classList.add('compare');",
        "}",
        "",
        "function unmarkCompare(c, i, j){",
        "  itemAt(c, i).classList.remove('compare');",
        "  itemAt(c, j).classList.remove('compare');",
        "}",
        "",
        "async function writeMark(c, i){",
        "  itemAt(c, i).classList.add('write');",
        "  await sleep(Math.round(getDelay() * 0.6));",
        "  itemAt(c, i).classList.remove('write');",
        "}"
      ]
    },
    {
      "path": "js/algorithms/swap.js",
      "type": "js",
      "content": [
        "function needSwap(a, b, DESC){",
        "  return DESC ? (a < b) : (a > b);",
        "}",
        "",
        "SortRegistry.register({",
        "  id: 'bubble',",
        "  name: 'Bubble',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    for(let i=0;i<n-1;i++){",
        "      for(let j=0;j<n-i-1;j++){",
        "        markCompare(c, j, j+1);",
        "        await sleep(getDelay());",
        "        if(needSwap(valueAt(c,j), valueAt(c,j+1), DESC)){",
        "          flipSwap(c, j, j+1);",
        "          await sleep(getDelay());",
        "        }",
        "        unmarkCompare(c, j, j+1);",
        "      }",
        "      itemAt(c, n-1-i).classList.add('sorted');",
        "    }",
        "    if(n>0) itemAt(c,0).classList.add('sorted');",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'selection',",
        "  name: 'Selection',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    for(let i=0;i<n-1;i++){",
        "      let best = i;",
        "      for(let j=i+1;j<n;j++){",
        "        markCompare(c, best, j);",
        "        await sleep(getDelay());",
        "        const a = valueAt(c, best);",
        "        const b = valueAt(c, j);",
        "        const better = DESC ? (b > a) : (b < a);",
        "        unmarkCompare(c, best, j);",
        "        if(better) best = j;",
        "      }",
        "      if(best !== i){",
        "        markCompare(c, i, best);",
        "        await sleep(getDelay());",
        "        flipSwap(c, i, best);",
        "        await sleep(getDelay());",
        "        unmarkCompare(c, i, best);",
        "      }",
        "      itemAt(c,i).classList.add('sorted');",
        "    }",
        "    if(n>0) itemAt(c,n-1).classList.add('sorted');",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'insertion',",
        "  name: 'Insertion',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    for(let i=1;i<n;i++){",
        "      let j=i;",
        "      while(j>0){",
        "        markCompare(c, j-1, j);",
        "        await sleep(getDelay());",
        "        if(needSwap(valueAt(c,j-1), valueAt(c,j), DESC)){",
        "          flipSwap(c, j-1, j);",
        "          await sleep(getDelay());",
        "          unmarkCompare(c, j-1, j);",
        "          j--;",
        "        }else{",
        "          unmarkCompare(c, j-1, j);",
        "          break;",
        "        }",
        "      }",
        "    }",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'quick',",
        "  name: 'Quick',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "",
        "    async function partition(lo, hi){",
        "      const pivot = valueAt(c, hi);",
        "      let i = lo;",
        "",
        "      for(let j=lo;j<hi;j++){",
        "        markCompare(c, j, hi);",
        "        await sleep(getDelay());",
        "        unmarkCompare(c, j, hi);",
        "",
        "        const goesLeft = DESC ? (valueAt(c,j) > pivot) : (valueAt(c,j) < pivot);",
        "        if(goesLeft){",
        "          if(i !== j){",
        "            markCompare(c, i, j);",
        "            await sleep(getDelay());",
        "            flipSwap(c, i, j);",
        "            await sleep(getDelay());",
        "            unmarkCompare(c, i, j);",
        "          }",
        "          i++;",
        "        }",
        "      }",
        "",
        "      markCompare(c, i, hi);",
        "      await sleep(getDelay());",
        "      flipSwap(c, i, hi);",
        "      await sleep(getDelay());",
        "      unmarkCompare(c, i, hi);",
        "      return i;",
        "    }",
        "",
        "    async function qs(lo, hi){",
        "      if(lo >= hi) return;",
        "      const p = await partition(lo, hi);",
        "      await qs(lo, p-1);",
        "      await qs(p+1, hi);",
        "    }",
        "",
        "    await qs(0, n-1);",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'shell',",
        "  name: 'Shell',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    for(let gap=Math.floor(n/2); gap>0; gap=Math.floor(gap/2)){",
        "      for(let i=gap;i<n;i++){",
        "        let j=i;",
        "        while(j-gap>=0){",
        "          markCompare(c, j-gap, j);",
        "          await sleep(getDelay());",
        "          const need = DESC ? (valueAt(c,j-gap) < valueAt(c,j)) : (valueAt(c,j-gap) > valueAt(c,j));",
        "          if(need){",
        "            flipSwap(c, j-gap, j);",
        "            await sleep(getDelay());",
        "            unmarkCompare(c, j-gap, j);",
        "            j -= gap;",
        "          }else{",
        "            unmarkCompare(c, j-gap, j);",
        "            break;",
        "          }",
        "        }",
        "      }",
        "    }",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'cocktail',",
        "  name: 'Cocktail',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    let start=0, end=n-1, swapped=true;",
        "",
        "    while(swapped){",
        "      swapped=false;",
        "      for(let i=start;i<end;i++){",
        "        markCompare(c, i, i+1);",
        "        await sleep(getDelay());",
        "        if(needSwap(valueAt(c,i), valueAt(c,i+1), DESC)){",
        "          flipSwap(c, i, i+1);",
        "          await sleep(getDelay());",
        "          swapped=true;",
        "        }",
        "        unmarkCompare(c, i, i+1);",
        "      }",
        "      if(n>0) itemAt(c,end).classList.add('sorted');",
        "      if(!swapped) break;",
        "      swapped=false;",
        "      end--;",
        "",
        "      for(let i=end;i>start;i--){",
        "        markCompare(c, i-1, i);",
        "        await sleep(getDelay());",
        "        if(needSwap(valueAt(c,i-1), valueAt(c,i), DESC)){",
        "          flipSwap(c, i-1, i);",
        "          await sleep(getDelay());",
        "          swapped=true;",
        "        }",
        "        unmarkCompare(c, i-1, i);",
        "      }",
        "      if(n>0) itemAt(c,start).classList.add('sorted');",
        "      start++;",
        "    }",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'comb',",
        "  name: 'Comb',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    let gap=n, swapped=true;",
        "    const shrink=1.3;",
        "",
        "    while(gap !== 1 || swapped){",
        "      gap = Math.floor(gap / shrink);",
        "      if(gap < 1) gap=1;",
        "      swapped=false;",
        "",
        "      for(let i=0;i+gap<n;i++){",
        "        const j=i+gap;",
        "        markCompare(c, i, j);",
        "        await sleep(getDelay());",
        "        if(needSwap(valueAt(c,i), valueAt(c,j), DESC)){",
        "          flipSwap(c, i, j);",
        "          await sleep(getDelay());",
        "          swapped=true;",
        "        }",
        "        unmarkCompare(c, i, j);",
        "      }",
        "    }",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'gnome',",
        "  name: 'Gnome',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    let i=1;",
        "",
        "    while(i<n){",
        "      if(i===0){ i=1; continue; }",
        "      markCompare(c, i-1, i);",
        "      await sleep(getDelay());",
        "      const inOrder = DESC ? (valueAt(c,i-1) >= valueAt(c,i)) : (valueAt(c,i-1) <= valueAt(c,i));",
        "      if(inOrder){",
        "        unmarkCompare(c, i-1, i);",
        "        i++;",
        "      }else{",
        "        flipSwap(c, i-1, i);",
        "        await sleep(getDelay());",
        "        unmarkCompare(c, i-1, i);",
        "        i--;",
        "      }",
        "    }",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});"
      ]
    },
    {
      "path": "js/algorithms/heap.js",
      "type": "js",
      "content": [
        "SortRegistry.register({",
        "  id: 'heap',",
        "  name: 'Heap',",
        "  type: 'swap',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    const isMaxHeap = !DESC; // ASC면 MaxHeap, DESC면 MinHeap",
        "",
        "    async function heapify(size, i){",
        "      let t=i;",
        "      const l=2*i+1, r=2*i+2;",
        "",
        "      if(l<size && (isMaxHeap ? valueAt(c,l) > valueAt(c,t) : valueAt(c,l) < valueAt(c,t))) t=l;",
        "      if(r<size && (isMaxHeap ? valueAt(c,r) > valueAt(c,t) : valueAt(c,r) < valueAt(c,t))) t=r;",
        "",
        "      if(t!==i){",
        "        flipSwap(c, i, t);",
        "        await sleep(getDelay());",
        "        await heapify(size, t);",
        "      }",
        "    }",
        "",
        "    for(let i=Math.floor(n/2)-1;i>=0;i--) await heapify(n,i);",
        "",
        "    for(let end=n-1; end>0; end--){",
        "      flipSwap(c, 0, end);",
        "      await sleep(getDelay());",
        "      itemAt(c,end).classList.add('sorted');",
        "      await heapify(end,0);",
        "    }",
        "    if(n>0) itemAt(c,0).classList.add('sorted');",
        "  }",
        "});"
      ]
    },
    {
      "path": "js/algorithms/write.js",
      "type": "js",
      "content": [
        "SortRegistry.register({",
        "  id: 'merge',",
        "  name: 'Merge',",
        "  type: 'write',",
        "  run: async (c, DESC) => {",
        "    const arr = [...c.children].map(el => Number(el.dataset.value));",
        "",
        "    async function merge(l,m,r){",
        "      const L = arr.slice(l,m+1);",
        "      const R = arr.slice(m+1,r+1);",
        "      let i=0,j=0,k=l;",
        "",
        "      while(i<L.length && j<R.length){",
        "        arr[k] = DESC ? (L[i] > R[j] ? L[i++] : R[j++])",
        "                      : (L[i] < R[j] ? L[i++] : R[j++]);",
        "        setValueAt(c, k, arr[k]);",
        "        await writeMark(c, k);",
        "        k++;",
        "      }",
        "      while(i<L.length){",
        "        arr[k]=L[i++];",
        "        setValueAt(c, k, arr[k]);",
        "        await writeMark(c, k);",
        "        k++;",
        "      }",
        "      while(j<R.length){",
        "        arr[k]=R[j++];",
        "        setValueAt(c, k, arr[k]);",
        "        await writeMark(c, k);",
        "        k++;",
        "      }",
        "    }",
        "",
        "    async function sort(l,r){",
        "      if(l>=r) return;",
        "      const m=(l+r)>>1;",
        "      await sort(l,m);",
        "      await sort(m+1,r);",
        "      await merge(l,m,r);",
        "    }",
        "",
        "    await sort(0, arr.length-1);",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'counting',",
        "  name: 'Counting',",
        "  type: 'write',",
        "  run: async (c, DESC) => {",
        "    const arr = [...c.children].map(el => Number(el.dataset.value));",
        "    const min = Math.min(...arr);",
        "    const max = Math.max(...arr);",
        "    const range = max - min + 1;",
        "    const count = new Array(range).fill(0);",
        "    for(const v of arr) count[v - min]++;",
        "",
        "    if(!DESC){",
        "      let idx = 0;",
        "      for(let v=min; v<=max; v++){",
        "        while(count[v-min] > 0){",
        "          setValueAt(c, idx, v);",
        "          await writeMark(c, idx);",
        "          idx++;",
        "          count[v-min]--;",
        "        }",
        "      }",
        "    }else{",
        "      let idx = 0;",
        "      for(let v=max; v>=min; v--){",
        "        while(count[v-min] > 0){",
        "          setValueAt(c, idx, v);",
        "          await writeMark(c, idx);",
        "          idx++;",
        "          count[v-min]--;",
        "        }",
        "      }",
        "    }",
        "",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'radix',",
        "  name: 'Radix (LSD)',",
        "  type: 'write',",
        "  run: async (c, DESC) => {",
        "    let arr = [...c.children].map(el => Number(el.dataset.value));",
        "    const max = Math.max(...arr);",
        "",
        "    for(let exp=1; Math.floor(max/exp) > 0; exp*=10){",
        "      const output = new Array(arr.length).fill(0);",
        "      const count = new Array(10).fill(0);",
        "",
        "      for(const v of arr){",
        "        const digit = Math.floor(v/exp) % 10;",
        "        count[digit]++;",
        "      }",
        "      for(let i=1;i<10;i++) count[i] += count[i-1];",
        "",
        "      for(let i=arr.length-1;i>=0;i--){",
        "        const v = arr[i];",
        "        const digit = Math.floor(v/exp) % 10;",
        "        output[count[digit]-1] = v;",
        "        count[digit]--;",
        "      }",
        "",
        "      arr = output;",
        "      for(let i=0;i<arr.length;i++){",
        "        setValueAt(c, i, arr[i]);",
        "        await writeMark(c, i);",
        "      }",
        "    }",
        "",
        "    if(DESC){",
        "      arr.reverse();",
        "      for(let i=0;i<arr.length;i++){",
        "        setValueAt(c, i, arr[i]);",
        "        await writeMark(c, i);",
        "      }",
        "    }",
        "",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'bucket',",
        "  name: 'Bucket',",
        "  type: 'write',",
        "  run: async (c, DESC) => {",
        "    const arr = [...c.children].map(el => Number(el.dataset.value));",
        "    const min = Math.min(...arr);",
        "    const max = Math.max(...arr);",
        "",
        "    const bucketCount = 10;",
        "    const buckets = Array.from({length: bucketCount}, () => []);",
        "    const span = (max - min + 1) / bucketCount;",
        "",
        "    for(const v of arr){",
        "      let idx = Math.floor((v - min) / span);",
        "      if(idx >= bucketCount) idx = bucketCount - 1;",
        "      buckets[idx].push(v);",
        "    }",
        "",
        "    for(const b of buckets) b.sort((a,b)=>a-b);",
        "    let merged = buckets.flat();",
        "    if(DESC) merged.reverse();",
        "",
        "    for(let i=0;i<merged.length;i++){",
        "      setValueAt(c, i, merged[i]);",
        "      await writeMark(c, i);",
        "    }",
        "",
        "    [...c.children].forEach(el=>el.classList.add('sorted'));",
        "  }",
        "});"
      ]
    },
    {
      "path": "js/algorithms/advanced.js",
      "type": "js",
      "content": [
        "function lt(a, b, DESC) {",
        "  return DESC ? (a > b) : (a < b);",
        "}",
        "",
        "function needSwapByOrder(a, b, DESC) {",
        "  return DESC ? (a < b) : (a > b);",
        "}",
        "",
        "SortRegistry.register({",
        "  id: 'intro',",
        "  name: 'IntroSort',",
        "  type: 'advanced',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    if (n <= 1) {",
        "      [...c.children].forEach(el => el.classList.add('sorted'));",
        "      return;",
        "    }",
        "",
        "    const INSERTION_THRESHOLD = 16;",
        "    const value = (i) => valueAt(c, i);",
        "",
        "    async function compareMark(i, j) {",
        "      markCompare(c, i, j);",
        "      await sleep(getDelay());",
        "      unmarkCompare(c, i, j);",
        "    }",
        "",
        "    async function insertionRange(lo, hi) {",
        "      for (let i = lo + 1; i <= hi; i++) {",
        "        let j = i;",
        "        while (j > lo) {",
        "          await compareMark(j - 1, j);",
        "          if (needSwapByOrder(value(j - 1), value(j), DESC)) {",
        "            flipSwap(c, j - 1, j);",
        "            await sleep(getDelay());",
        "            j--;",
        "          } else {",
        "            break;",
        "          }",
        "        }",
        "      }",
        "    }",
        "",
        "    async function heapifyRange(base, size, i) {",
        "      let t = i;",
        "      const l = 2 * i + 1;",
        "      const r = 2 * i + 2;",
        "      const idx = (k) => base + k;",
        "      const isMaxHeap = !DESC;",
        "",
        "      if (l < size) {",
        "        const a = value(idx(l));",
        "        const b = value(idx(t));",
        "        const better = isMaxHeap ? (a > b) : (a < b);",
        "        if (better) t = l;",
        "      }",
        "",
        "      if (r < size) {",
        "        const a = value(idx(r));",
        "        const b = value(idx(t));",
        "        const better = isMaxHeap ? (a > b) : (a < b);",
        "        if (better) t = r;",
        "      }",
        "",
        "      if (t !== i) {",
        "        await compareMark(idx(i), idx(t));",
        "        flipSwap(c, idx(i), idx(t));",
        "        await sleep(getDelay());",
        "        await heapifyRange(base, size, t);",
        "      }",
        "    }",
        "",
        "    async function heapSortRange(lo, hi) {",
        "      const size = hi - lo + 1;",
        "      if (size <= 1) return;",
        "",
        "      for (let i = Math.floor(size / 2) - 1; i >= 0; i--) {",
        "        await heapifyRange(lo, size, i);",
        "      }",
        "",
        "      for (let end = size - 1; end > 0; end--) {",
        "        await compareMark(lo, lo + end);",
        "        flipSwap(c, lo, lo + end);",
        "        await sleep(getDelay());",
        "        await heapifyRange(lo, end, 0);",
        "      }",
        "    }",
        "",
        "    async function partition(lo, hi) {",
        "      const pivot = value(hi);",
        "      let i = lo;",
        "",
        "      for (let j = lo; j < hi; j++) {",
        "        await compareMark(j, hi);",
        "        const goesLeft = lt(value(j), pivot, DESC);",
        "        if (goesLeft) {",
        "          if (i !== j) {",
        "            await compareMark(i, j);",
        "            flipSwap(c, i, j);",
        "            await sleep(getDelay());",
        "          }",
        "          i++;",
        "        }",
        "      }",
        "",
        "      await compareMark(i, hi);",
        "      flipSwap(c, i, hi);",
        "      await sleep(getDelay());",
        "      return i;",
        "    }",
        "",
        "    async function intro(lo, hi, depthLimit) {",
        "      const len = hi - lo + 1;",
        "      if (len <= 1) return;",
        "",
        "      if (len <= INSERTION_THRESHOLD) {",
        "        await insertionRange(lo, hi);",
        "        return;",
        "      }",
        "",
        "      if (depthLimit === 0) {",
        "        await heapSortRange(lo, hi);",
        "        return;",
        "      }",
        "",
        "      const p = await partition(lo, hi);",
        "      await intro(lo, p - 1, depthLimit - 1);",
        "      await intro(p + 1, hi, depthLimit - 1);",
        "    }",
        "",
        "    const depthLimit = 2 * Math.floor(Math.log2(n));",
        "    await intro(0, n - 1, depthLimit);",
        "    [...c.children].forEach(el => el.classList.add('sorted'));",
        "  }",
        "});",
        "",
        "SortRegistry.register({",
        "  id: 'tim',",
        "  name: 'TimSort (educational)',",
        "  type: 'advanced',",
        "  run: async (c, DESC) => {",
        "    const n = c.children.length;",
        "    if (n <= 1) {",
        "      [...c.children].forEach(el => el.classList.add('sorted'));",
        "      return;",
        "    }",
        "",
        "    let arr = [...c.children].map(el => Number(el.dataset.value));",
        "",
        "    function calcMinRun(x) {",
        "      let r = 0;",
        "      while (x >= 32) {",
        "        r |= (x & 1);",
        "        x >>= 1;",
        "      }",
        "      return x + r;",
        "    }",
        "",
        "    const minRun = calcMinRun(n);",
        "",
        "    async function writeAll(from, to) {",
        "      for (let i = from; i <= to; i++) {",
        "        setValueAt(c, i, arr[i]);",
        "        await writeMark(c, i);",
        "      }",
        "    }",
        "",
        "    async function insertionOnArray(lo, hi) {",
        "      for (let i = lo + 1; i <= hi; i++) {",
        "        const x = arr[i];",
        "        let j = i - 1;",
        "        while (j >= lo && (DESC ? (arr[j] < x) : (arr[j] > x))) {",
        "          arr[j + 1] = arr[j];",
        "          j--;",
        "        }",
        "        arr[j + 1] = x;",
        "        await writeAll(lo, i);",
        "      }",
        "    }",
        "",
        "    function reverseRun(lo, hi) {",
        "      while (lo < hi) {",
        "        const t = arr[lo];",
        "        arr[lo] = arr[hi];",
        "        arr[hi] = t;",
        "        lo++;",
        "        hi--;",
        "      }",
        "    }",
        "",
        "    const runs = [];",
        "    let i = 0;",
        "    while (i < n) {",
        "      let runStart = i;",
        "      let runEnd = i;",
        "",
        "      if (i === n - 1) {",
        "        runs.push({ lo: runStart, hi: runEnd });",
        "        break;",
        "      }",
        "",
        "      const ascending = arr[i] <= arr[i + 1];",
        "      while (runEnd + 1 < n) {",
        "        const a = arr[runEnd];",
        "        const b = arr[runEnd + 1];",
        "        if (ascending ? (a <= b) : (a >= b)) runEnd++;",
        "        else break;",
        "      }",
        "",
        "      if (!ascending) reverseRun(runStart, runEnd);",
        "",
        "      const need = Math.min(n - 1, runStart + minRun - 1);",
        "      if (runEnd < need) {",
        "        runEnd = need;",
        "        await insertionOnArray(runStart, runEnd);",
        "      } else {",
        "        await writeAll(runStart, runEnd);",
        "      }",
        "",
        "      runs.push({ lo: runStart, hi: runEnd });",
        "      i = runEnd + 1;",
        "    }",
        "",
        "    async function merge(lo, mid, hi) {",
        "      const left = arr.slice(lo, mid + 1);",
        "      const right = arr.slice(mid + 1, hi + 1);",
        "      let p = 0, q = 0, k = lo;",
        "",
        "      while (p < left.length && q < right.length) {",
        "        if (left[p] <= right[q]) arr[k++] = left[p++];",
        "        else arr[k++] = right[q++];",
        "      }",
        "      while (p < left.length) arr[k++] = left[p++];",
        "      while (q < right.length) arr[k++] = right[q++];",
        "",
        "      await writeAll(lo, hi);",
        "    }",
        "",
        "    let size = 1;",
        "    while (size < runs.length) {",
        "      for (let r = 0; r + size < runs.length; r += 2 * size) {",
        "        const left = runs[r];",
        "        const right = runs[r + size];",
        "        const lo = left.lo;",
        "        const mid = left.hi;",
        "        const hi = right.hi;",
        "        await merge(lo, mid, hi);",
        "        left.hi = hi;",
        "        runs.splice(r + 1, size);",
        "      }",
        "      size *= 2;",
        "    }",
        "",
        "    if (DESC) {",
        "      arr.reverse();",
        "      for (let k = 0; k < n; k++) {",
        "        setValueAt(c, k, arr[k]);",
        "        await writeMark(c, k);",
        "      }",
        "    }",
        "",
        "    [...c.children].forEach(el => el.classList.add('sorted'));",
        "  }",
        "});"
      ]
    },
    {
      "path": "js/app.js",
      "type": "js",
      "content": [
        "const bars = document.getElementById('bars');",
        "const randomBtn = document.getElementById('random');",
        "const goBtn = document.getElementById('go');",
        "const pauseBtn = document.getElementById('pause');",
        "const resumeBtn = document.getElementById('resume');",
        "const stopBtn = document.getElementById('stop');",
        "",
        "const countSlider = document.getElementById('count');",
        "const algoSelect = document.getElementById('algo');",
        "const dirToggle = document.getElementById('direction');",
        "",
        "const algoCard = document.getElementById('algoCard');",
        "const algoTitle = document.getElementById('algoTitle');",
        "const algoStatus = document.getElementById('algoStatus');",
        "const algoMeta = document.getElementById('algoMeta');",
        "const algoDesc = document.getElementById('algoDesc');",
        "",
        "let DESC = false;",
        "let running = false;",
        "",
        "const ALGO_INFO = {",
        "  bubble:   { title:'버블 정렬', meta:'복잡도: O(n²) / 안정적: O', desc:'인접한 두 값을 비교해 교환하면서 큰(또는 작은) 값이 끝으로 이동합니다. 단순하지만 데이터가 많으면 느립니다.' },",
        "  selection:{ title:'선택 정렬', meta:'복잡도: O(n²) / 안정적: X', desc:'남은 구간에서 최댓값(또는 최솟값)을 찾아 현재 위치와 교환합니다. 비교가 많지만 구현이 단순합니다.' },",
        "  insertion:{ title:'삽입 정렬', meta:'복잡도: O(n²) / 안정적: O', desc:'앞쪽을 정렬된 상태로 유지하며 새 원소를 알맞은 위치에 삽입합니다. 거의 정렬된 데이터에 강합니다.' },",
        "  quick:    { title:'퀵 정렬', meta:'평균: O(n log n), 최악: O(n²) / 안정적: X', desc:'피벗을 기준으로 분할(파티션) 후 재귀 정렬합니다. 평균적으로 매우 빠릅니다.' },",
        "  shell:    { title:'셸 정렬', meta:'대략: O(n^1.3~n^2) / 안정적: X', desc:'간격(gap)을 두고 삽입 정렬을 반복하며 gap을 줄여갑니다. 멀리 있는 값들이 점프하듯 정렬됩니다.' },",
        "  cocktail: { title:'칵테일 셰이커 정렬', meta:'복잡도: O(n²) / 안정적: O', desc:'버블 정렬을 좌→우, 우→좌 번갈아 수행합니다. 양쪽으로 거품이 이동해 흐름이 직관적입니다.' },",
        "  comb:     { title:'콤 정렬', meta:'평균: O(n log n) 근처 / 안정적: X', desc:'큰 gap으로 비교를 시작해 gap을 줄입니다. 초반에 빠르게 대략 정렬됩니다.' },",
        "  gnome:    { title:'놈 정렬', meta:'복잡도: O(n²) / 안정적: O', desc:'앞으로 가다가 순서가 틀리면 한 칸 뒤로 물러나 교환합니다. 움직임이 재미있습니다.' },",
        "  heap:     { title:'힙 정렬', meta:'복잡도: O(n log n) / 안정적: X', desc:'힙을 구성하고 루트 값을 끝으로 보내며 힙을 재구성합니다. 최악 케이스에도 O(n log n)입니다.' },",
        "  merge:    { title:'병합 정렬', meta:'복잡도: O(n log n) / 안정적: O', desc:'분할 후 병합하며 정렬합니다. 값이 덮어써지는 흐름을 보기 좋습니다.' },",
        "  counting: { title:'계수 정렬', meta:'복잡도: O(n + k) / 안정적: 구현에 따라', desc:'값의 범위(k)가 작을 때 카운트 배열로 정렬합니다. 비교 정렬이 아니어서 빠를 수 있습니다.' },",
        "  radix:    { title:'기수 정렬(LSD)', meta:'복잡도: O(d(n + k)) / 안정적: O', desc:'자리수별로 안정 정렬을 반복합니다. 정수 데이터에 강하고 버킷 개념을 이해하기 좋습니다.' },",
        "  bucket:   { title:'버킷 정렬', meta:'평균: O(n + k) 근처 / 안정적: 구현에 따라', desc:'구간별 버킷에 분배 후 각 버킷을 정렬하고 합칩니다. 분포가 고르면 매우 빠릅니다.' },",
        "  intro:    { title:'인트로 정렬(IntroSort)', meta:'복잡도: O(n log n) / 안정적: X', desc:'퀵 정렬 기반 + 깊이 초과 시 힙 정렬 전환 + 작은 구간 삽입 정렬. 실전 철학 하이브리드입니다.' },",
        "  tim:      { title:'팀 정렬(TimSort, 교육용)', meta:'실전: O(n log n) / 안정적: O', desc:'정렬된 런(run)을 활용해 효율을 높입니다. 여기서는 런 탐지/확장 + 병합 흐름을 교육용으로 단순화해 보여줍니다.' }",
        "};",
        "",
        "function setCardState(state, statusText){",
        "  algoCard.dataset.state = state;",
        "  algoStatus.textContent = statusText;",
        "}",
        "",
        "function updateAlgoCard(){",
        "  const id = algoSelect.value;",
        "  const info = ALGO_INFO[id] || { title:'알고리즘', meta:'복잡도: - / 안정성: -', desc:'설명이 없습니다.' };",
        "  algoTitle.textContent = info.title;",
        "  algoMeta.textContent = info.meta;",
        "  algoDesc.textContent = info.desc;",
        "}",
        "",
        "function fillAlgoOptions(){",
        "  const list = SortRegistry.list();",
        "  algoSelect.innerHTML = '';",
        "  for(const a of list){",
        "    const opt = document.createElement('option');",
        "    opt.value = a.id;",
        "    opt.textContent = a.name;",
        "    algoSelect.appendChild(opt);",
        "  }",
        "  algoSelect.value = 'heap';",
        "  updateAlgoCard();",
        "  setCardState('idle', '대기 중');",
        "}",
        "",
        "function generateRandom(){",
        "  if(running) return;",
        "  clearMarks(bars);",
        "  bars.innerHTML = '';",
        "  const count = Number(countSlider.value);",
        "",
        "  for(let i=0;i<count;i++){",
        "    const v = Math.floor(Math.random()*100)+1;",
        "    const item = document.createElement('div');",
        "    item.className = 'item';",
        "    item.dataset.value = String(v);",
        "",
        "    const bar = document.createElement('div');",
        "    bar.className = 'bar';",
        "    bar.style.height = `${v * 3}px`;",
        "",
        "    const label = document.createElement('div');",
        "    label.className = 'label';",
        "    label.textContent = String(v);",
        "",
        "    item.appendChild(bar);",
        "    item.appendChild(label);",
        "    bars.appendChild(item);",
        "  }",
        "}",
        "",
        "function setControlsEnabled(enabled){",
        "  randomBtn.disabled = !enabled;",
        "  goBtn.disabled = !enabled;",
        "  algoSelect.disabled = !enabled;",
        "  countSlider.disabled = !enabled;",
        "  dirToggle.disabled = !enabled;",
        "}",
        "",
        "function setRunButtons(){",
        "  pauseBtn.disabled = !running;",
        "  resumeBtn.disabled = !running;",
        "  stopBtn.disabled = !running;",
        "}",
        "",
        "dirToggle.onchange = e => DESC = e.target.checked;",
        "algoSelect.onchange = () => {",
        "  updateAlgoCard();",
        "  if(!running) setCardState('idle', '대기 중');",
        "};",
        "",
        "randomBtn.onclick = generateRandom;",
        "",
        "pauseBtn.onclick = () => {",
        "  if(!running) return;",
        "  SortController.pause();",
        "  setCardState('paused', '일시정지');",
        "};",
        "",
        "resumeBtn.onclick = () => {",
        "  if(!running) return;",
        "  SortController.resume();",
        "  setCardState('running', '정렬 중');",
        "};",
        "",
        "stopBtn.onclick = () => {",
        "  if(!running) return;",
        "  SortController.stop();",
        "  setCardState('stopped', '중지됨');",
        "};",
        "",
        "goBtn.onclick = async () => {",
        "  if(running) return;",
        "  running = true;",
        "  SortController.reset();",
        "  clearMarks(bars);",
        "",
        "  setControlsEnabled(false);",
        "  setRunButtons();",
        "  setCardState('running', '정렬 중');",
        "",
        "  try{",
        "    const algo = SortRegistry.get(algoSelect.value);",
        "    await algo.run(bars, DESC);",
        "    if(!SortController.isStopped()){",
        "      setCardState('done', '정렬 완료');",
        "    }",
        "  } catch (e) {",
        "    if (String(e?.message) === 'SORT_STOPPED') {",
        "      // STOP으로 중지됨",
        "    } else {",
        "      console.error(e);",
        "      setCardState('stopped', '오류로 중단');",
        "    }",
        "  } finally {",
        "    running = false;",
        "    SortController.reset();",
        "    setControlsEnabled(true);",
        "    setRunButtons();",
        "  }",
        "};",
        "",
        "fillAlgoOptions();",
        "generateRandom();",
        "setRunButtons();"
      ]
    }
  ],
  "notes": [
    "PAUSE/RESUME/STOP은 sleep()가 SortController 상태를 주기적으로 확인하는 방식이라, 대부분의 정렬 코드 수정 없이 전체 적용된다.",
    "STOP을 누르면 sleep()에서 Error('SORT_STOPPED')를 throw하여 즉시 탈출한다(try/catch로 app.js에서 처리).",
    "swap 기반 정렬은 flipSwap(FLIP)으로 DOM 위치를 교환해 실제 막대가 이동하는 애니메이션을 만든다.",
    "write 기반 정렬은 setValueAt + writeMark로 값이 덮어써지는(재배치) 흐름을 보여준다.",
    "막대 기본색은 css/main.css의 --bar 한 곳에서 통일 제어한다(현재 인디고 #6366f1)."
  ],
  "next_ideas": [
    "정렬 진행률(%) 표시 및 비교/스왑/쓰기 횟수 카운터",
    "정렬 중 알고리즘 변경 시 자동 STOP 후 새 알고리즘으로 즉시 실행 옵션",
    "TimSort run 구간을 색으로 표시(런 카드/하이라이트)",
    "Counting/Radix/Bucket에서 보조 UI(카운트 배열/버킷 리스트) 시각화"
  ]
}
